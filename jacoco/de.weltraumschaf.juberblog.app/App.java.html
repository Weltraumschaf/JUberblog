<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>App.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JUberblog</a> &gt; <a href="index.source.html" class="el_package">de.weltraumschaf.juberblog.app</a> &gt; <span class="el_source">App.java</span></div><h1>App.java</h1><pre class="source lang-java linenums">package de.weltraumschaf.juberblog.app;

import de.weltraumschaf.juberblog.cmd.SubCommand;
import de.weltraumschaf.juberblog.JUberblog;
import com.beust.jcommander.ParameterException;
import de.weltraumschaf.commons.application.ApplicationException;
import de.weltraumschaf.commons.application.IOStreams;
import de.weltraumschaf.commons.application.InvokableAdapter;
import de.weltraumschaf.commons.application.Version;
import de.weltraumschaf.commons.system.Environments;
import de.weltraumschaf.commons.system.ExitCode;
import de.weltraumschaf.commons.validate.Validate;
import de.weltraumschaf.juberblog.core.BlogConfiguration;
import de.weltraumschaf.juberblog.core.Constants;
import de.weltraumschaf.juberblog.core.ExitCodeImpl;
import de.weltraumschaf.juberblog.cmd.create.CreateSubCommand;
import de.weltraumschaf.juberblog.cmd.install.InstallSubCommand;
import de.weltraumschaf.juberblog.options.Options;
import de.weltraumschaf.juberblog.options.Options.Command;
import de.weltraumschaf.juberblog.cmd.publish.PublishSubCommand;
import java.io.UnsupportedEncodingException;

/**
 * Main class invoked by JVM.
 *
 * @since 1.0.0
 * @author Sven Strittmatter
 */
public final class App extends InvokableAdapter {

    /**
     * To obtain environment variables.
     */
    private final Environments.Env env;
    /**
     * Command line arguments.
     */
<span class="fc" id="L38">    private final Options options = new Options();</span>
    /**
     * Provides sub commands.
     */
<span class="fc" id="L42">    private Factory subCommands = new FactoryImpl();</span>

    /**
     * Convenience constructor with default environment.
     *
     * @param args must not be {@code null}
     */
    public App(final String[] args) {
<span class="fc" id="L50">        this(args, Environments.defaultEnv());</span>
<span class="fc" id="L51">    }</span>

    /**
     * Dedicated constructor.
     *
     * @param args must not be {@code null}
     * @param env must not be {@code null}
     */
    App(final String[] args, final Environments.Env env) {
<span class="fc" id="L60">        super(args);</span>
<span class="fc" id="L61">        this.env = Validate.notNull(env, &quot;env&quot;);</span>
<span class="fc" id="L62">    }</span>

    /**
     * Main entry point of VM.
     *
     * @param args CLI arguments from VM
     */
    public static void main(final String[] args) {
<span class="nc" id="L70">        final App invokable = new App(args);</span>
<span class="nc" id="L71">        invokable.debug = invokable.isEnvDebug();</span>

        try {
<span class="nc" id="L74">            InvokableAdapter.main(</span>
                invokable,
                IOStreams.newDefault());
<span class="nc" id="L77">        } catch (final UnsupportedEncodingException ex) {</span>
<span class="nc" id="L78">            handleFatals(invokable, ex, ExitCodeImpl.CANT_READ_IO_STREAMS, &quot;Can't create IO streams!\n&quot;);</span>
<span class="nc" id="L79">        }</span>
<span class="nc" id="L80">    }</span>

    /**
     * Handles all not yet catched exceptions in main function.
     *
     * @param invokable must not be {@code null}
     * @param cause must not be {@code null}
     * @param code must not be {@code null}
     * @param prefix must not be {@code null}
     */
    private static void handleFatals(
        final App invokable,
        final Throwable cause,
        final ExitCode code,
        final String prefix) {
        // CHECKSTYLE:OFF
        // At this point we do not have IO streams.
<span class="nc" id="L97">        System.err.print(Validate.notNull(prefix, &quot;prefix&quot;));</span>
<span class="nc" id="L98">        System.err.println(Validate.notNull(cause, &quot;cause&quot;).getMessage());</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (Validate.notNull(invokable, &quot;invokable&quot;).isEnvDebug()) {</span>
<span class="nc" id="L101">            cause.printStackTrace(System.err);</span>
        }

        // CHECKSTYLE:ON
<span class="nc" id="L105">        invokable.exit(Validate.notNull(code, &quot;code&quot;).getCode());</span>
<span class="nc" id="L106">    }</span>

    @Override
    public void execute() throws Exception {
        final Command commandName;

        try {
<span class="fc" id="L113">            options.parse(getArgs());</span>
<span class="fc" id="L114">            commandName = options.getParsedCommand();</span>
<span class="fc" id="L115">        } catch (final ParameterException ex) {</span>
<span class="fc" id="L116">            throw badArgumentError(ex, options.getParsedCommand());</span>
<span class="fc" id="L117">        }</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (Command.NONE == commandName) {</span>
<span class="fc" id="L120">            executeMainCommand();</span>
        } else {
<span class="fc" id="L122">            executeSubCommand(commandName);</span>
        }
<span class="fc" id="L124">    }</span>

    /**
     * Executes the main application code here.
     *
     * @throws ApplicationException on any application error such as bad arguments
     */
    private void executeMainCommand() throws ApplicationException {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (options.isHelp()) {</span>
<span class="fc" id="L133">            showHelp();</span>
<span class="fc" id="L134">            return;</span>
        }

<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (options.getMain().isVersion()) {</span>
<span class="fc" id="L138">            final Version version = JUberblog.generateWithDefaultConfig(options, getIoStreams()).version();</span>
<span class="fc" id="L139">            showVersion(version);</span>
<span class="fc" id="L140">            return;</span>
        }

<span class="fc" id="L143">        throw badArgumentError();</span>
    }

    /**
     * Executes a sub command named by fist CLI argument.
     *
     * @param must not be {@code null}
     * @throws Exception if anything went wrong
     */
    private void executeSubCommand(final Command commandName) throws Exception {
<span class="fc" id="L153">        Validate.notNull(commandName, &quot;commandName&quot;);</span>
        final JUberblog registry;

<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (options.isHelp()) {</span>
<span class="fc" id="L157">            showHelp(commandName);</span>
<span class="fc" id="L158">            return;</span>
        }

<span class="pc bpc" id="L161" title="1 of 4 branches missed.">        switch (commandName) {</span>
            case INSTALL:
<span class="fc" id="L163">                registry = JUberblog.generateWithDefaultConfig(options, getIoStreams());</span>
<span class="fc" id="L164">                break;</span>
            case CREATE: {
<span class="fc" id="L166">                final BlogConfiguration config = JUberblog.generateConfiguration(options.getCreate());</span>
<span class="fc" id="L167">                registry = JUberblog.generate(options, getIoStreams(), config);</span>
<span class="fc" id="L168">                break;</span>
            }
            case PUBLISH: {
<span class="fc" id="L171">                final BlogConfiguration config = JUberblog.generateConfiguration(options.getPublish());</span>
<span class="fc" id="L172">                registry = JUberblog.generate(options, getIoStreams(), config);</span>
<span class="fc" id="L173">                break;</span>
            }
            default:
<span class="nc" id="L176">                throw badArgumentError(&quot;Unsupported command!&quot;, commandName);</span>
        }

<span class="fc" id="L179">        subCommands.forName(commandName, registry).execute();</span>
<span class="fc" id="L180">    }</span>

    /**
     * Throw a generic bad CLI argument error.
     *
     * @throws ApplicationException always
     */
    private ApplicationException badArgumentError() throws ApplicationException {
<span class="fc" id="L188">        return badArgumentError(&quot;Bad arguments!&quot;, Command.NONE);</span>
    }

    /**
     * Throw bad CLI argument error with custom message.
     *
     * @param messageFormat additional error message
     * @throws ApplicationException always
     */
    private ApplicationException badArgumentError(final String messageFormat, final Command name, final Object... args) throws ApplicationException {
<span class="fc" id="L198">        return badArgumentError(messageFormat, null, name, args);</span>
    }

    /**
     * Throw a generic bad CLI argument error with exception for debug output the stack trace.
     *
     * @param ex may be {@code null}
     * @throws ApplicationException always
     */
    private ApplicationException badArgumentError(final ParameterException ex, final Command name) throws ApplicationException {
<span class="fc" id="L208">        return badArgumentError(&quot;Bad arguments (cause: %s)!&quot;, ex, name, ex.getMessage());</span>
    }

    /**
     * Throw bad CLI argument error with custom message with exception for debug output the stack trace.
     *
     * @param messageFormat additional error message
     * @param ex may be {@code null}
     * @throws ApplicationException always
     */
    private ApplicationException badArgumentError(final String messageFormat, final ParameterException ex, final Command name, final Object... args) throws ApplicationException {
<span class="fc" id="L219">        return new ApplicationException(ExitCodeImpl.BAD_ARGUMENT, errorMessage(messageFormat, name, args), ex);</span>
    }

    /**
     * Appends usage to given message.
     *
     * @param messageFormat must not be {@code null} or empty
     * @param name must not be {@code null}
     * @param args optional arguments for the message format string.
     * @return never {@code null} or empty
     */
    private String errorMessage(final String messageFormat, final Command name, final Object... args) {
<span class="fc" id="L231">        return new StringBuilder()</span>
            .append(String.format(Validate.notEmpty(messageFormat, &quot;messageFormat&quot;), args))
            .append(Constants.DEFAULT_NEW_LINE.toString())
            .append(&quot;Usage: &quot;)
            .append(Constants.COMMAND_NAME.toString())
            .append(' ')
            .append(options.usage(name))
            .toString();
    }

    /**
     * Show help message.
     */
    private void showHelp() {
<span class="fc" id="L245">        showHelp(Command.NONE);</span>
<span class="fc" id="L246">    }</span>

    private void showHelp(final Command name) {
<span class="fc" id="L249">        getIoStreams().println(options.help(name));</span>
<span class="fc" id="L250">    }</span>

    /**
     * Show version message.
     */
    private void showVersion(final Version version) {
<span class="fc" id="L256">        getIoStreams().println(version.getVersion());</span>
<span class="fc" id="L257">    }</span>

    /**
     * Whether debug output is enabled by environment variable.
     *
     * @return {@code true} for enabled, else {@code false}
     */
    boolean isEnvDebug() {
<span class="fc" id="L265">        return &quot;true&quot;.equalsIgnoreCase(env.get(Constants.ENVIRONMENT_VARIABLE_DEBUG.toString()).trim());</span>
    }

    /**
     * Injection point for testing.
     *
     * @param newSubCommands must not be {@code null}
     */
    void injectFactory(final Factory newSubCommands) {
<span class="fc" id="L274">        this.subCommands = Validate.notNull(newSubCommands, &quot;factory&quot;);</span>
<span class="fc" id="L275">    }</span>

    /**
     * Creates sub command instances.
     */
    public interface Factory {

        /**
         * Creates sub command for name.
         * &lt;p&gt;
         * Throws {@link IllegalArgumentException} for unsupported names.
         * &lt;/p&gt;
         *
         * @param name must not be {@code null}
         * @param registry must not be {@code null}
         * @return never {@code null}, always new instance
         */
        SubCommand forName(final Command name, final JUberblog registry);
    }

    /**
     * Default implementation.
     */
<span class="fc" id="L298">    static final class FactoryImpl implements Factory {</span>

        @Override
        public SubCommand forName(final Command name, final JUberblog registry) {
<span class="fc bfc" id="L302" title="All 4 branches covered.">            switch (Validate.notNull(name, &quot;name&quot;)) {</span>
                case CREATE:
<span class="fc" id="L304">                    return new CreateSubCommand(registry);</span>
                case INSTALL:
<span class="fc" id="L306">                    return new InstallSubCommand(registry);</span>
                case PUBLISH:
<span class="fc" id="L308">                    return new PublishSubCommand(registry);</span>
                default:
<span class="fc" id="L310">                    throw new IllegalArgumentException(String.format(&quot;Unsupported command name: '%s'!&quot;, name));</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>